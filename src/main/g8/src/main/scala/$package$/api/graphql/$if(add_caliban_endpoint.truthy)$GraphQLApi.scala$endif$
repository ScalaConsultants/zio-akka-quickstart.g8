package $package$.api.graphql

import java.util.UUID

import akka.actor.ActorSystem
import akka.http.scaladsl.server.Directives._
import akka.http.scaladsl.server.Route
import caliban.GraphQL.graphQL
import caliban.interop.play.PlayJsonBackend
import caliban.schema.Annotations.GQLDescription
import caliban.schema.GenericSchema
import caliban.wrappers.ApolloTracing.apolloTracing
import caliban.wrappers.Wrappers._
import caliban.{ AkkaHttpAdapter, CalibanError, GraphQL, RootResolver }
import $package$.api._
import $package$.application.ApplicationService
import $package$.domain._
import zio._
import zio.clock._
import zio.duration._
import zio.logging._

import scala.language.postfixOps

object GraphQLApi extends GenericSchema[ItemRepository with Subscriber] {

  trait Service {
    def routes: Route
  }

  private final case class ItemName(name: String)
  private final case class ItemPrice(price: BigDecimal)
  private final case class ItemInput(name: String, price: BigDecimal)

  private final case class Queries(
    @GQLDescription("Find items by name")
    itemByName: ItemName => RIO[ItemRepository with Subscriber, List[Item]],
    @GQLDescription("Find items cheaper than specified price")
    cheaperThan: ItemPrice => RIO[ItemRepository with Subscriber, List[Item]],
    @GQLDescription("Get all items")
    allItems: RIO[ItemRepository with Subscriber, List[Item]],
    @GQLDescription("Get item by ID")
    item: ItemId => RIO[ItemRepository with Subscriber, Option[Item]]
  )

  private final case class Mutations(
    addItem: ItemInput => RIO[ItemRepository with Subscriber, ItemId],
    deleteItem: ItemId => RIO[ItemRepository with Subscriber, Int]
  )

  private val slowQueriesHandler: (Duration, String) => URIO[Logging, Unit] = (time, query) => {
    log.locallyM(logContext => ZIO(UUID.randomUUID()).option.map(logContext.annotate(LogAnnotation.CorrelationId, _))) {
      log.warn(s"Slow query took \${time.render}:\n\$query")
    }
  }

  private def runService[A](f: ZIO[ItemRepository with Subscriber, DomainError, A]): RIO[ItemRepository with Subscriber, A] =
    f.mapError(_.asThrowable)

  private val api: GraphQL[Clock with Logging with ItemRepository with Subscriber] = {
    graphQL(
      RootResolver(
        Queries(
          args => runService(ApplicationService.getItemByName(args.name)),
          args => runService(ApplicationService.getItemsCheaperThan(args.price)),
          runService(ApplicationService.getItems),
          id => runService(ApplicationService.getItem(id))
        ),
        Mutations(
          item => runService(ApplicationService.addItem(item.name, item.price)),
          id => runService(ApplicationService.deleteItem(id))
        )
      )
    ) @@
    maxFields(200) @@                                // query analyzer that limit query fields
    maxDepth(30) @@                                  // query analyzer that limit query depth
    timeout(3 seconds) @@                            // wrapper that fails slow queries
    onSlowQueries(500 millis)(slowQueriesHandler) @@ // wrapper that logs slow queries
    apolloTracing                                    // wrapper for https://github.com/apollographql/apollo-tracing
  }

  val live =
    ZLayer.fromServicesM[
      Logger[String],
      ItemRepository.Service,
      Subscriber.Service,
      ActorSystem,
      Clock with Logging,
      CalibanError.ValidationError,
      GraphQLApi.Service
    ] { (logger, itemRepositoryService, eventsService, actorSystem) =>
      implicit val system  = actorSystem
      implicit val ec      = system.dispatcher
      implicit val runtime = Runtime.default.map(_ ++ Has(logger) ++ Has(itemRepositoryService) ++ Has(eventsService))
      val adapter          = AkkaHttpAdapter(new PlayJsonBackend)
      api.interpreter.map { interpreter =>
        new Service {
          def routes: Route =
            path("api" / "graphql") {
              adapter.makeHttpService(interpreter)
            } ~
              path("graphiql") {
                getFromResource("graphql/graphiql.html")
              }
        }
      }
    }

  // accessors
  val routes: URIO[GraphQLApi, Route] = ZIO.access[GraphQLApi](a => Route.seal(a.get.routes))
}
